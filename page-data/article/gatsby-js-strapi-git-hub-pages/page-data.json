{"componentChunkName":"component---src-templates-article-js","path":"/article/gatsby-js-strapi-git-hub-pages","result":{"data":{"strapiArticle":{"strapiId":7,"title":"GatsbyJS + Strapi + GitHub Pages快速上手, 還有Azure Static Web Apps... ","description":"介紹一套能快速上手建立個人部落格的方案,\n除了免費之外, 還有.....","content":"Azure Static Web App\n=================\n\n起源\n-----\n故事從我最近在Azure Cloud裡面看到一個新的服務開始: [Azure static web apps](https://azure.microsoft.com/zh-tw/services/app-service/static \"Azure static web apps\")。\n\n本有點納悶最簡單的hosting靜態網頁，了無新意，放進Azure幹嘛?? \n\n但看了介紹之後發現, 這組服務的功能基本上會比較像是[GitHub Pages](https://pages.github.com/ \"GitHub Pages\")，\n而Deploy流程會是將其主要網頁內容檔案使用Git控管放上GitHub repository後，在每次git push進GitHub 的repository後經由觸發Action後將網頁檔案資源上到Azure Static Web App，\n當然上述的網頁資源可以是簡單的HTML，也可以是含有HTML/JS/CSS/image等檔案的 ReactJS/Angular/Vue 程式。\n\n![AzureStaticWebApps](https://azurecomcdn.azureedge.net/cvt-aa77de8d08c7abaf5307d82c869eaab798030946ed7a71c45d007fea97171722/images/page/services/app-service/static/value-prop-2.png)\n\n\n優點\n-----\n那麼, 我們就用GitHub Pages就好啦, 幹嘛還要Azure static webapps??\n\n我想有人注意到上圖的\"Api Azure Function\"了，在功能上Azure Static Web Apps能強過於(或說更方便於)GitHub Pages，\n就是他幫你把後端的API server都準備好了(是使用Azure Functions serverless服務)，也整合好了(**代表靜態網頁和API的endpoint會在同一個domain URL下,可以避免Cross domain問題**)。\n\n對於開發前端應用的人，如果你今天用了ReactJS/ Angular / Vue等框架開發了應用，同時也需要有後端的API供你的前端應用在運行時可以呼叫，那這組Azure static webapps使用起來應該會相當方便!!\n\n目前Azure Static Web app還在Preview階段，是完全免費的，有興趣可以體驗看看!!\n\n\n進一步\n--------\n再進一步的瀏覽Azure Static Web App相關網頁及文件，看到這兩篇:\n\n- [使用 Gatsby 和 Azure Static Web Apps 建立及發佈靜態 Web 應用程式](https://docs.microsoft.com/zh-tw/learn/modules/create-deploy-static-webapp-gatsby-app-service/ \"使用 Gatsby 和 Azure Static Web Apps 建立及發佈靜態 Web 應用程式\")\n- [教學課程：將 Jekyll 網站發佈至 Azure Static Web Apps Preview](https://docs.microsoft.com/zh-tw/azure/static-web-apps/publish-jekyll \"教學課程：將 Jekyll 網站發佈至 Azure Static Web Apps Preview\")\n\n於是發現了有趣的工具: 靜態網站產生器(static web site generator / blog generator)。\n\n****\n\n關於 靜態網站產生器/部落格產生器\n============================\n上面文章的兩個Generator: GatsbyJS 和 Jekyll，其中Jekyll是基於Ruby生態系的，而GatsbyJS是基於JS和ReactJS生態系的。\n\nGenerator是要做啥用呢?\n\n\n我們先來回想網站的網頁通常是怎麼生成的:\n- 比較古早的架構的做法\n  1. 使用者開啟瀏覽器造訪網站網址開啟網頁\n  2. Server端程式透過ASP/JSP/PHP等或其他框架程式即時撈取後端資料來源 (可能是DB或是API等來源) 來生成最終靜態網頁\n\n- 比較新的架構做法 \n  1. 使用者開啟瀏覽器造訪網站網址開啟網頁  \n  2. 網站回復靜態前端網頁UI及程式檔案(HTML/CSS/JS; 此處程式可能有使用Anrular/ReactJS/Vue等框架或是其他JS library)\n  3. 接著前端的JS程式在Client端瀏覽器執行, 並即時撈取後端資料來源(通常透過Restful或GraphQL呼叫API)，動態生成DOM呈現最終網頁內容\n\n上列不管哪種做法，都會發現到 **\"資料撈取\"** 這個動作都會是在使用者造訪網頁時 **\"即時\"** 執行的。\n這可以保證使用者看到的都是最新的最即時的資料。\n\n\n然而與單純的靜態網頁相比:\n- 動態網頁每次造訪時都要有存取資料的動作，故一定會要額外多花時間存取資料，所以就會比較慢一點點。 (我們先屏除考量快取機制)\n- 既然是要放動態網頁，那麼Hosting這些網頁的主機勢必就要支援對應的後端語言環境(如Java /.net / PHP)等，如果是自己公司的主機要裝啥都好解決，但如果是要放在其他代管主機廠商或是雲端環境，就要注意是否支援所需的環境。由於需要有動態環境的支援，相對的Hosting部分也會多些花費。\n\n\n然而有些網站類型，如 部落格 或是 展示型的企業網站， 後端資料內容更新並不算頻繁。\n我們換個方向來思考: 如果我們在每次更新後端資料內容時，做一次build動作來混合後端資料來源與前端UI，產生最終的 **靜態網頁檔案** ，並將這些靜態網頁檔案Hosting上網路空間，那麼一來可以省掉動態主機的花費，二來使用者在瀏覽網頁時也更加快速(因為不用撈後端資料了)，這也不失為一個好的解決方案~~\n\n回神!!  我們剛剛問題點是: Generator是做啥用的?? 對~~ 就是上面這個用法~~  幫我們拿來產生靜態網頁用的。\n\n如果有些年紀的人有用過Teleport pro這套砍站下載以供離線瀏覽的軟體，大概就可以把Generator在build時做的事情比擬是Teleport在把整個網站的所有網頁下載下來一般。只是Teleport是把載下來的靜態網頁放電腦裡慢慢看，而我們用Generator產生的靜態網頁，是要進一步Deploy靜態網頁空間上去，供大眾瀏覽的~~\n\n\n前述的兩套Generator，Jekyll會比較簡單易用，GatsbyJS學習曲線就會較陡峭。\nGatsbyJS建議要有ReactJS的基本技能，用起來才會比較順手。\n\n兩個工具的詳細比較，可以參考:\n- [How Not to Go Wrong When Choosing a Static Website Generator? Gatsby vs Jekyll](https://medium.com/javascript-in-plain-english/how-not-to-go-wrong-when-choosing-a-static-website-generator-gatsby-vs-jekyll-510cea59e6e1 \"How Not to Go Wrong When Choosing a Static Website Generator? Gatsby vs Jekyll\")\n- [Comparison of Gatsby vs Jekyll vs Hugo](https://www.gatsbyjs.com/features/jamstack/gatsby-vs-jekyll-vs-hugo \"Comparison of Gatsby vs Jekyll vs Hugo\")\n \n個人選擇GatsbyJS是因為我對JS生態系比較熟，也有開發ReactJS應用的經驗，另外GatsbyJS經由Plugin可以支援GraphQL。\n\nGatsbyJS是透過Plugin的概念來支援各種資料來源類型，在build時配合這些Plugin就可以存取到你的後端資料。 當然除了資料存取功能外，Plugin還能達到其他類型目的的功能(如SASS支援等)。舉凡在做Build時要額外做處理的部分都可以透過Plugin做擴充。\n\n[GatsbyJS的Plugin Library](https://www.gatsbyjs.com/plugins \"GatsbyJS的Plugin Library\") ← 點這\n\n****\n\n Headless CMS - Strapi\n==================\n有了GatsbyJS這工具來做自己的Blog前端頁面，那麼後端呢??\n\n我的後端除了要是個部落格內容的資料庫外，我還希望這後台還要提供有基本的文章內容編輯功能~~\n\n咦?? 這種自助式前台展示，後端編輯的概念不就是現行CMS(Content Management System)的型式了嗎??\n\n只是我們並不需要CMS的前台展示部分，因為透過GatsbyJS和ReactJS我們可以高度客製化我們的前端頁面長成怎麼個樣子~~  不必受限於CMS制式或是受限的前端樣板!!\n\n\n所以我們需要的是一個帶後台資料庫及後台編輯功能的CMS，並且這個CMS能提供API讓我們的GatsbyJS和ReactJS在執行build靜態頁面時可以撈取CMS後台所編輯的文章資料庫內容。\n這個僅有後台，不提供前台頁面的CMS產品就叫做無頭的(Headless) CMS。\n\n經由參考\n[Build a static blog with Gatsby and Strapi](https://strapi.io/blog/build-a-static-blog-with-gatsby-and-strapi \"Build a static blog with Gatsby and Strapi\")\n這篇文章，得知了[Strapi](https://strapi.io/)這套基於Node.JS的開源CMS~~\n\n且依循了上列文章的引導執行下列指令生成Strapi專案檔案:\n\n        `npx create-strapi-app backend  --quickstart --template https://github.com/strapi/strapi-template-blog`\n\n上列指令利用了Strapi提供的樣板的概念，使我們建立起來的Strapi專案就包含樣板作者預先幫我們建立好的資料結構(Article, Category, User, Writer.. 等資料結構)。讓我們快速上手生成我們所需要的Blog後台。 \n*(P.S. 這裡所謂的CMS的資料結構，可以理解為資料庫的Table。)*\n\n由於只有我自己一個人維護Blog內容，所以我就在我的本機跑Strapi就夠用了。 如果有需要多人協作(如多人共筆寫Blog文章) ，可以嘗試把Strapi架在內網主機上，或是雲端主機上。\n\n如果懶得自己架設CMS主機，那麼也可以考慮像是[Contentful CMS](https://www.contentful.com)這種線上服務。Gatsby也有Plugin銜接存取Contentful CMS。Contentful CMS有免費方案的，也有收費方案的，[詳情參考這裡](https://www.contentful.com/pricing/ \"Contentful Pricing\")← \n\nStrapi支援Restful和GraphQL的API型式接口，詳請參閱Strapi官方文件~~\n在Strapi內部資料儲存方面，支援的資料庫目前有SQLite, PostgreSQL, MySQL, MongoDB ，沒有特別配置的話，預設使用SQLite。一樣詳請參閱Strapi官方文件~~\n\n\n****\nGitHub Pages\n===========\nGitHub Pages的功能就是把GitHub當作靜態網頁空間來用。用Git push來取代FTP上傳網頁檔案，而且不用花錢!!\n\n所以我們連開Azure static web apps都不用了(畢竟目前我的Blog也用不到Azure Functions API部分)。\n\n關於GitHub Pages這邊有篇詳盡的介紹 [從零開始: 用github pages 上傳靜態網站](https://medium.com/%E9%80%B2%E6%93%8A%E7%9A%84-git-git-git/%E5%BE%9E%E9%9B%B6%E9%96%8B%E5%A7%8B-%E7%94%A8github-pages-%E4%B8%8A%E5%82%B3%E9%9D%9C%E6%85%8B%E7%B6%B2%E7%AB%99-fa2ae83e6276) 我沒辦法寫得比這篇好，所以請各位就看這篇介紹囉~~\n\n\n\n\n\n\n\n\n","publishedAt":"2021-02-01T04:00:00.000Z","tags":[{"tagName":"Strapi","slug":"Strapi"},{"tagName":"GatsbyJS","slug":"GatsbyJS"}],"image":{"publicURL":"/static/83d8363909eea0b4eaeeb217a6cedc20/1c2bfaf2d5f6ce22df404627a5abaa7a.png","childImageSharp":{"fixed":{"src":"/static/83d8363909eea0b4eaeeb217a6cedc20/497c6/1c2bfaf2d5f6ce22df404627a5abaa7a.png"}}},"author":{"name":"豆腐","picture":{"childImageSharp":{"fixed":{"src":"/static/814afda129be66d802b5e2e6878690ab/91664/68ec1329a0c03ec83fd29493e1db9bf2.png"}}}}}},"pageContext":{"slug":"gatsby-js-strapi-git-hub-pages"}},"staticQueryHashes":["161018792","2031881183","3406376217","557794130"]}